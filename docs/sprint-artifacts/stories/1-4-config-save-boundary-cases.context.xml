<story-context id="1-4-config-save-boundary-cases" v="1.0">
  <metadata>
    <epicId>epic-1</epicId>
    <storyId>1-4</storyId>
    <title>配置保存边界情况处理</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-16</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/1-4-config-save-boundary-cases.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>最终用户</asA>
    <iWant>即使在异常情况下也能确保配置保存</iWant>
    <soThat>不会丢失我的重要设置</soThat>
    <tasks>
      <task id="1">在config_widget.py中重写closeEvent()方法</task>
      <task id="2">在closeEvent开始时调用super().closeEvent()保持默认行为</task>
      <task id="3">实现待保存更改检查逻辑(has_pending_changes标志)</task>
      <task id="4">实现立即触发强制保存的方法</task>
      <task id="5">测试应用关闭时保存触发逻辑</task>
      <task id="6">在closeEvent中实现定时器状态检查(self.save_timer.isActive())</task>
      <task id="7">如果有活动定时器,调用self.save_timer.stop()停止它</task>
      <task id="8">停止后立即调用auto_save_config()执行保存</task>
      <task id="9">测试活动定时器检测准确性</task>
      <task id="10">测试定时器停止和立即保存流程</task>
      <task id="11">在强制保存完成后验证文件是否存在</task>
      <task id="12">读取保存的配置文件验证内容完整性</task>
      <task id="13">比较内存中的配置与文件中的配置一致性</task>
      <task id="14">实现配置项数量验证(确保没有丢失配置项)</task>
      <task id="15">测试完整的数据完整性检查流程</task>
      <task id="16">在closeEvent中包装保存逻辑在try-except块中</task>
      <task id="17">捕获文件权限错误并记录到日志(logging.error)</task>
      <task id="18">实现备用保存方案(如保存到临时文件)</task>
      <task id="19">显示用户友好的错误消息(如果UI仍可用)</task>
      <task id="20">测试各种异常场景(权限错误、磁盘满、只读文件系统)</task>
      <task id="21">验证应用不会崩溃并正常退出</task>
      <task id="22">在closeEvent结束时清理所有QTimer资源</task>
      <task id="23">确保save_timer被正确删除或置为None</task>
      <task id="24">如果存在clear_timer也一并清理</task>
      <task id="25">释放相关对象引用以便垃圾回收</task>
      <task id="26">使用Python的gc.collect()验证内存清理(调试用)</task>
      <task id="27">使用QApplication.processEvents()确保事件循环处理完成</task>
      <task id="28">测试正常关闭流程(有/无配置变更)</task>
      <task id="29">测试快速关闭(定时器刚启动时关闭)</task>
      <task id="30">测试定时器即将触发时关闭(1.9秒时)</task>
      <task id="31">测试保存失败时的关闭流程</task>
      <task id="32">测试多次快速打开/关闭应用</task>
      <task id="33">验证没有资源泄漏(使用内存分析工具)</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">应用关闭时的强制保存 - Given 配置修改后用户关闭应用, When 触发应用关闭事件时, Then 应该立即检查是否有待保存的配置更改, And 如果有则立即触发一次强制保存</criterion>
    <criterion id="2">活动定时器检查 - Given 应用正在关闭, When 检查保存定时器状态时, Then 应该检测到是否有活动的QTimer等待触发, And 如果有活动定时器应立即停止并执行保存</criterion>
    <criterion id="3">数据完整性保证 - Given 强制保存已触发, When 配置文件写入完成时, Then 应该验证文件已成功写入磁盘, And 不应该出现任何数据丢失或配置项缺失</criterion>
    <criterion id="4">异常情况下的优雅处理 - Given 保存过程中发生异常(如文件权限错误), When 应用关闭时, Then 应该记录错误日志, And 尝试使用备用保存方案, And 不应该导致应用崩溃</criterion>
    <criterion id="5">定时器资源清理 - Given 应用正在关闭, When 关闭流程结束时, Then 应该正确清理所有QTimer资源, And 释放相关内存, And 不应该留下僵尸定时器</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc name="epics.md" path="docs/epics.md" section="史诗1: 基础设施现代化">包含史诗1的完整故事分解</doc>
      <doc name="architecture-decisions" path="docs/bmm-architecture-decisions-2025-11-16.md" section="需求5: 配置管理无感（自动保存）">详细的架构决策和实现指导</doc>
      <doc name="component-inventory" path="docs/component-inventory.md">系统组件清单</doc>
      <doc name="development-guide" path="docs/development-guide.md">开发指南和模式</doc>
      <doc name="story-1-1-context" path="docs/sprint-artifacts/stories/1-1-project-setup-and-infrastructure-initialization.context.xml">基础设施初始化上下文</doc>
      <doc name="story-1-2-context" path="docs/sprint-artifacts/stories/1-2-config-auto-save-core-functionality.context.xml">自动保存核心功能上下文</doc>
      <doc name="story-1-3-context" path="docs/sprint-artifacts/stories/1-3-auto-save-status-feedback-system.context.xml">自动保存状态反馈系统上下文</doc>
    </docs>

    <code>
      <file name="config_widget.py" path="ui_qt/widgets/config_widget.py">
        <class name="ConfigWidget">
          <method name="__init__">初始化配置管理界面</method>
          <method name="setup_ui">设置UI布局</method>
          <method name="load_current_config">加载当前配置到界面</method>
          <method name="update_config_from_ui">从界面更新配置</method>
          <method name="apply_config">应用配置</method>
          <method name="save_config">保存配置</method>
          <method name="on_config_selected">配置选择变更处理</method>
          <method name="on_proxy_state_changed">代理状态变更处理</method>
          <signal name="config_changed">配置变更信号</signal>
        </class>
        <snippet name="closeEvent_implementation">
def closeEvent(self, event):
    try:
        # 检查是否有活动定时器
        if hasattr(self, 'save_timer') and self.save_timer and self.save_timer.isActive():
            logging.debug(f"Active save_timer detected, stopping and forcing save")
            self.save_timer.stop()
            self.auto_save_config()

        # 检查是否有待保存的更改
        if hasattr(self, 'has_pending_changes') and self.has_pending_changes:
            logging.debug(f"Pending changes detected, forcing save")
            self.auto_save_config()

    except Exception as e:
        logging.exception(f"Error during forced save on close: {e}")
        # 尝试备用保存方案
        try:
            self.save_config_to_temp_file()
        except:
            pass  # 即使备用方案也失败，也不阻止应用关闭

    finally:
        # 清理定时器资源
        if hasattr(self, 'save_timer') and self.save_timer:
            if self.save_timer.isActive():
                self.save_timer.stop()
            self.save_timer.deleteLater()
            self.save_timer = None

        if hasattr(self, 'clear_timer') and self.clear_timer:
            if self.clear_timer.isActive():
                self.clear_timer.stop()
            self.clear_timer.deleteLater()
            self.clear_timer = None

        # 确保事件循环处理完成
        QApplication.processEvents()

        # 调用父类closeEvent保持默认行为
        super().closeEvent(event)
        </snippet>
        <snippet name="auto_save_config_method">
def auto_save_config(self):
    """执行自动保存配置"""
    try:
        self.update_config_from_ui()
        success = save_config(self.config)

        if success:
            logging.info(f"Configuration auto-saved successfully")
            # 重置待保存标志
            if hasattr(self, 'has_pending_changes'):
                self.has_pending_changes = False
            # 显示成功状态
            if hasattr(self, 'status_bar') and self.status_bar:
                self.status_bar.set_success_state("配置已自动保存")
        else:
            logging.error(f"Configuration auto-save failed")
            if hasattr(self, 'status_bar') and self.status_bar:
                self.status_bar.set_error_state("配置保存失败，请重试")

    except Exception as e:
        logging.exception(f"Exception during auto-save: {e}")
        if hasattr(self, 'status_bar') and self.status_bar:
            self.status_bar.set_error_state("配置保存失败，请重试")
        </snippet>
        <snippet name="save_config_to_temp_file">
def save_config_to_temp_file(self):
    """备用保存方案：保存到临时文件"""
    import tempfile
    import shutil
    from pathlib import Path

    try:
        # 创建临时文件
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False, encoding='utf-8') as f:
            import json
            json.dump(self.config, f, ensure_ascii=False, indent=4)
            temp_path = f.name

        # 尝试复制到配置目录作为备份
        config_dir = Path.home() / ".config" / "InfinitQuill" / "backups"
        config_dir.mkdir(parents=True, exist_ok=True)

        backup_path = config_dir / f"config_backup_{int(time.time())}.json"
        shutil.copy2(temp_path, backup_path)

        # 清理临时文件
        Path(temp_path).unlink(missing_ok=True)

        logging.warning(f"Configuration saved to backup file: {backup_path}")
        return str(backup_path)

    except Exception as e:
        logging.exception(f"Failed to save backup configuration: {e}")
        return None
        </snippet>
      </file>

      <file name="status_bar.py" path="ui_qt/widgets/status_bar.py">
        <class name="StatusBar">
          <method name="__init__">初始化状态栏组件，设置UI和定时器</method>
          <method name="setup_ui">设置状态栏UI布局</method>
          <method name="show_message">显示状态消息</method>
          <method name="clear_message">清除状态消息</method>
          <method name="set_error_state">设置错误状态（红色，3秒后清除）</method>
          <method name="clear_error_state">清除错误状态</method>
          <method name="set_warning_state">设置警告状态（橙色，3秒后清除）</method>
          <method name="clear_warning_state">清除警告状态</method>
          <method name="set_success_state">设置成功状态（绿色，3秒后清除）</method>
          <method name="clear_success_state">清除成功状态</method>
          <method name="update_time">更新时间显示</method>
          <attribute name="status_label">主状态标签</attribute>
          <attribute name="message_timer">消息定时器</attribute>
        </class>
      </file>

      <file name="config_manager.py" path="config_manager.py">
        <function name="save_config">保存配置到文件</function>
        <function name="load_config">从文件加载配置</function>
        <function name="get_user_config_path">获取用户配置文件路径</function>
        <function name="get_config_directory">获取跨平台配置目录</function>
      </file>
    </code>

    <dependencies>
      <package name="PySide6" version="6.8.0">Qt框架 - QTimer用于实现2秒延迟自动保存，closeEvent用于应用关闭处理</package>
      <package name="PySide6-Addons" version="6.8.0">Qt附加组件</package>
      <package name="langchain" version="0.3.27">AI集成框架</package>
      <package name="openai" version="1.106.1">OpenAI API</package>
      <package name="chromadb" version="1.0.20">向量数据库</package>
      <package name="sentence-transformers" version="5.1.0">文本嵌入模型</package>
      <package name="coloredlogs" version="15.0.1">日志记录</package>
      <package name="rich" version="14.1.0">日志格式化</package>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint name="架构约束">必须遵循Story 1.1-1.3建立的基础设施模式</constraint>
    <constraint name="存储位置">配置文件存储在跨平台用户配置目录</constraint>
    <constraint name="向后兼容">保持向后兼容现有配置格式</constraint>
    <constraint name="错误处理">遵循错误处理统一模式</constraint>
    <constraint name="资源清理">确保所有QTimer资源正确清理，防止内存泄漏</constraint>
    <constraint name="优雅降级">即使保存失败也不应阻止应用正常关闭</constraint>
    <constraint name="跨平台兼容性">支持Windows、macOS、Linux的关闭行为</constraint>
    <constraint name="数据完整性">确保配置数据在关闭过程中不丢失</constraint>
    <constraint name="用户体验">即使技术问题也不应阻塞用户正常操作</constraint>
  </constraints>

  <interfaces>
    <interface name="QWidget.closeEvent" type="PySide6.QtWidgets">窗口关闭事件，需要重写以处理边界情况</interface>
    <interface name="QTimer" type="PySide6.QtCore">定时器资源管理，包括isActive()、stop()、deleteLater()</interface>
    <interface name="QApplication.processEvents" type="PySide6.QtWidgets">确保事件循环处理完成</interface>
    <interface name="save_config" type="function">config_manager.py中的配置保存函数</interface>
    <interface name="auto_save_config" type="method">ConfigWidget中的自动保存方法</interface>
    <interface name="status_bar.set_success_state" type="method">status_bar.py中的成功状态显示方法</interface>
    <interface name="status_bar.set_error_state" type="method">status_bar.py中的错误状态显示方法</interface>
    <interface name="logging" type="module">Python日志记录模块，用于错误记录和调试</interface>
  </interfaces>

  <tests>
    <standards>
      <standard name="错误处理模式">使用try-except-finally模式，记录日志并显示用户友好的错误消息</standard>
      <standard name="资源清理模式">使用deleteLater()和置空引用的方式确保QTimer资源完全清理</standard>
      <standard name="日志记录模式">使用标准logging模块，区分INFO/DEBUG/WARNING/ERROR级别</standard>
      <standard name="边界测试">测试定时器在不同状态(刚启动、即将触发、已触发、已停止)下的行为</standard>
      <standard name="异常测试">测试文件权限错误、磁盘空间不足、只读文件系统等异常情况</standard>
      <standard name="资源泄漏测试">使用内存分析工具验证没有定时器或内存泄漏</standard>
      <standard name="数据完整性测试">验证关闭过程中配置数据的完整性和一致性</standard>
      <standard name="跨平台测试">在Windows、macOS、Linux上测试关闭行为的一致性</standard>
    </standards>

    <locations>
      <location>ui_qt/widgets/config_widget.py - closeEvent()主实现和资源清理</location>
      <location>config_manager.py - 配置保存逻辑验证点</location>
      <location>app.log - 错误日志记录位置</location>
    </locations>

    <ideas>
      <idea name="单元测试">为closeEvent()方法编写单元测试，验证不同边界情况</idea>
      <idea name="集成测试">测试完整的应用关闭流程，从用户点击X到进程退出</idea>
      <idea name="边界测试">测试定时器在不同时间点的行为(0.1秒、1.9秒、2.1秒)</idea>
      <idea name="异常测试">模拟文件权限错误、磁盘满、只读文件系统等异常场景</idea>
      <idea name="资源泄漏测试">使用objgraph或tracemalloc验证没有内存泄漏</idea>
      <idea name="跨平台测试">在不同操作系统上验证关闭行为的一致性</idea>
      <idea name="性能测试">测试快速打开/关闭应用的性能和资源使用情况</idea>
      <idea name="数据恢复测试">验证备用保存方案的数据恢复能力</idea>
    </ideas>
  </tests>
</story-context>